docs {
  # Infinite Vocabulary API
  
  The Infinite Vocabulary API is the backend service for a dynamic vocabulary learning application. It provides a RESTful interface for managing users, words, categories, and their relationships, built with Python, Flask, and Firestore.
  
  ---
  
  ## Features
  
  - **User Management:** Secure user registration and profile management.
  - **Word & Sub-Collection CRUD:** Full create, read, update, and delete operations for words, including their descriptions and examples.
  - **Category Management:** Allows users to create custom categories and link words to them for better organization.
  - **Architectural Patterns:** Demonstrates a clean, modern backend architecture using Pydantic for data validation and serialization.
  - **Search:** Prefix-based search functionality across both words and categories.
  - **Testing:** Includes a comprehensive API test suite using [Bruno](https://www.usebruno.com/).
  
  ---
  
  ## Architecture Overview
  
  This project utilizes a clean architecture with a clear separation of concerns, designed for maintainability and scalability. The data flows through distinct layers:
  
  **Routes → Schema → Service → Factory → Model → DAL**
  
  - **Routes:** Handles HTTP requests and responses. It's responsible for calling the service layer and serializing the final model for the client.
  - **Schema:** Uses Pydantic to define and validate the structure of incoming request data (the API contract).
  - **Service:** The orchestration layer. It coordinates the application's business logic, calling factories and data access layers.
  - **Factory:** Responsible for business rule validation and the creation of internal data objects (Models).
  - **Model:** Uses Pydantic to define the internal, type-safe representation of our data entities (e.g., a `User` or `Category`). It also handles serialization for API responses.
  - **DAL (Data Access Layer):** The only layer that communicates directly with the Firestore database.
  
  The project currently contains two co-existing patterns:
  1.  **Modern Pattern (`categories`, `users`):** Fully utilizes the Pydantic-driven flow described above.
  2.  **Legacy Pattern (`words`):** A functional but older pattern that relies on manual dictionary handling and `pyhumps` for case conversion. The long-term goal is to migrate all features to the modern pattern.
  
  ---
  
  ## API Endpoints
  
  ### Users (`/api/v1/users`)
  - `POST /`: Get an existing user's data or create a new record upon first sign-in.
  - `GET /me`: Get the current authenticated user's profile.
  - `PATCH /me`: Update the current authenticated user's name.
  
  ### Words (`/api/v1/words`)
  - `GET /`: List all words for the user.
  - `POST /`: Create a new word with an initial description and example.
  - `GET /<word_id>`: Get details for a specific word.
  - `PATCH /<word_id>`: Update a word's text.
  - `DELETE /<word_id>`: Delete a word and its sub-collections.
  - `POST /<word_id>/star`: Add a star to a word.
  - Full CRUD for sub-collections at `/descriptions` and `/examples`.
  
  ### Categories (`/api/v1/categories`)
  - `GET /`: List all categories for the user.
  - `POST /`: Create a new category.
  - `GET /<category_id>`: Get details for a specific category.
  - `PUT /<category_id>`: Update a category's name and/or color.
  - `DELETE /<category_id>`: Delete a category.
  
  ### Word-Category Linking
  - `GET /<category_id>/words`: Get all words within a specific category.
  - `POST /<category_id>/words`: Link a word to a category.
  - `DELETE /<category_id>/words/<word_id>`: Unlink a word from a category.
  
  ### Search (`/api/v1/search`)
  - `GET /?q=<query>`: Perform a prefix search for words and categories.
  
  ---
  
  ## Local Setup & Installation
  
  ### Prerequisites
  - Python 3.9+
  - `pip` for package management
  - A Google Cloud project with Firestore enabled
  - Firebase Admin SDK credentials (`serviceAccountKey.json`)
  
  ### Installation Steps
  
  1.  **Clone the repository:**
      ```sh
      git clone <your-repository-url>
      cd <repository-folder>
      ```
  
  2.  **Create and activate a virtual environment:**
      ```sh
      python -m venv venv
      source venv/bin/activate
      ```
  
  3.  **Install dependencies:**
      *(Note: You will need to generate a `requirements.txt` file)*
      ```sh
      pip freeze > requirements.txt
      pip install -r requirements.txt
      ```
  
  4.  **Set Environment Variables:**
      The application requires the path to your Firebase service account key.
      ```sh
      export INFINITE_SECURITY="/path/to/your/serviceAccountKey.json"
      ```
  
  5.  **Run the application:**
      ```sh
      flask run
      ```
      The API will be available at `http://localhost:5000`.
  
  ---
  
  ## Running Tests
  
  The API includes a full test suite built with **Bruno**.
  1. Open the Bruno desktop client.
  2. Import the `Bruno_Infinite_Vocab_Backend.json` collection from the project root.
  3. Configure your environment variables in Bruno (`apiUrl`, `authUrl`, etc.).
  4. Run the tests using the Bruno test runner.
}
