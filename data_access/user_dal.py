"""User Data Access Layer"""

from typing import Optional

from firebase_admin import firestore

from models import User
from utils import DatabaseError


def create_user(db, user: User) -> User:
    """Saves a new user to Firestore and returns the created user."""
    try:
        # Prepare the data, excluding fields that are None or generated by the DB
        user_data = {
            "user_id": user.user_id,
            "user_name": user.user_name,
            "user_code": user.user_code,
            "total_score": user.total_score,
            "createdAt": firestore.SERVER_TIMESTAMP,
            "updatedAt": firestore.SERVER_TIMESTAMP,
        }
        # Use the user_id from the auth token as the document ID
        doc_ref = db.collection("users").document(user.user_id)
        doc_ref.set(user_data)

        # Retrieve the document to get server-generated timestamps
        created_doc = doc_ref.get()
        return User(**created_doc.to_dict(), userId=created_doc.id)

    except Exception as e:
        raise DatabaseError(f"Failed to create user: {e}") from e


def get_user_by_id(db, user_id: str) -> Optional[User]:
    """Gets a user from Firestore by their document ID."""
    try:
        doc_ref = db.collection("users").document(user_id)
        doc = doc_ref.get()

        if not doc.exists:
            return None

        # Unpack the dictionary from Firestore and add the document ID
        return User(**doc.to_dict(), userId=doc.id)

    except Exception as e:
        raise DatabaseError(f"Failed to get user by ID: {e}") from e


def update_user(db, user_id: str, updates: dict) -> Optional[User]:
    """Updates a user document in Firestore."""
    try:
        doc_ref = db.collection("users").document(user_id)
        doc = doc_ref.get()

        if not doc.exists:
            return None

        updates["updatedAt"] = firestore.SERVER_TIMESTAMP
        doc_ref.update(updates)

        # Return the updated document
        updated_doc = doc_ref.get()
        return User(**updated_doc.to_dict(), userId=updated_doc.id)

    except Exception as e:
        raise DatabaseError(f"Failed to update user: {e}") from e


# We don't need a specific delete function for now, as users deleting
# their own accounts is a more complex process we can add later if needed.
# It often involves clean-up of associated data. We'll follow YAGNI here.


def list_all_users(db) -> list[User]:
    """Retrieves all user documents from the users collection."""
    try:
        users = []
        docs = db.collection("users").stream()
        for doc in docs:
            users.append(User(**doc.to_dict(), userId=doc.id))
        return users
    except Exception as e:
        raise DatabaseError(f"Failed to list all users: {e}") from e
